#!/usr/bin/env python3
#
# ## flat(1) -- flat
#
# [code](flat)
#
# ### SYNOPSIS
#
#     flat [<cols>]
#
# ### Description
#
# Print whole the inputs as multiple rows with given number of cols.
# In default, it just removes the new lines.
#
# ### Usage
#
#     seq 10 | flat
#     1 2 3 4 5 6 7 8 9 10
#
#     # Comma separeted file
#     $ cat myfile
#     AA,AB,AC,AD
#     BA,BB,BC,BD
#     CA,CB,CC,CD
#     DA,DB,DC,DD
#
#     # Field separator(fs) option is useful for keeping comma.
#     $ cat myfile | flat --fs=, 8
#     AA,AB,AC,AD,BA,BB,BC,BD
#     CA,CB,CC,CD,DA,DB,DC,DD
#

import sys
import argparse
import fileinput
import re

sys.path.append('lib')
import utils

utils.exit_by_sigpipe()

# Parse args
parser = argparse.ArgumentParser()
utils.add_common_options(parser)

parser.add_argument(
    'cols', type=int, nargs='?', default=float('inf'),
    help='number of cols')

args = parser.parse_args()
del sys.argv[:]

ifs, ofs = utils.get_iofs(args)

# output
array = []
ifs_regex = re.compile('[%s]' % ifs) if ifs else ''

for line in fileinput.input():
    if not line.strip():
        continue
    for item in utils.split(ifs_regex, line.strip()):
        array.append(item)
        if len(array) >= args.cols:
            print(ofs.join(array))
            del array[:args.cols]

if len(array) > 0:
    print(ofs.join(array))
